\documentclass{ctexart}
\begin{document}

\section{显示系统}

本部分介绍基本的显示系统的设计原则.

基本的显示系统负责向屏幕绘制图像. 这个系统是整个项目最重要的部分.

基本显示系统预计将能够支持 Kirikiri 引擎能够支持的所有特效, 另外可以支持一些 3D
效果.

本部分使用 OpenGL 实现.

要求本子系统不占用过多的 CPU, 在 GF 8600M 上达到 60 FPS. 

\subsection{基本原理}

绘制指令链表. 本系统核心部分是一个链表, 表中的每一个元素是一个(特效)绘制函数.上
层通过接口调整这个链表, 定义绘制指令. 本系统以预定 FPS 的频率按顺序执行这些绘制
指令, 完成绘制.

特效分两种: 位置特效(震动, 旋转)和画面特效(柔化, 百叶窗). 


示例:

1. 绘制背景: 向链表头添加一个绘制函数(效果: 显示), 在某位置显示某个纹理;
2. 背景扭曲特效: 使用"扭曲"特效绘制函数绘制某个纹理;
3. 旋转+缩放: 通过位置特效计算显示位置(扭曲矩阵), 通过某个参数决定纹理的大小, 在
	指定的绘制指令前后插入矩阵旋转和矩阵恢复指令.
3. 将特效用于多个图层: 
	例1: 画面整体震动, 某个元素相对于背景旋转上升; 某个元素(例如前端窗口)相
		对于屏幕静止:
		将震动矩阵置于开始震动的绘制指令图层前, 将恢复矩阵置于最后的图层
		之后; 将旋转矩阵置于旋转的纹理前, 后面放置恢复矩阵; 在相对静止的
		部分前加载元矩阵, 也可以通过使用"相对xxx静止"的属性在绘制时使之
		静止.
	例2: 对数个纹理一起使用某种画面特效:
		方案1: 重定向: 在开始的纹理前插入重定向标记, 在后面插入解除重定
			向标记, 之后使用特效指令绘制重定向后的纹理.
			1. 重定向过程中旋转矩阵可能需要重新计算. 
			2. 重定向可以嵌套.

\subsection{和其它部分的关系}

1. 事件系统: 如果出错应该发送事件?

2. 窗口系统: 是窗口系统的支持;

3. 系统配置: 见后文``配置接口'';

4. 输入系统: 无关.

\subsection{向上提供的接口}

数据结构:

绘制指令(RenderCommand):

名称;
绘制函数指针;
销毁函数指针;
特性检查; (第一次安装这种指令时, 应该检查一下平台是否支持. 有的平台无法支持
render 程序, 有的平台不支持向纹理输出)
参数;
开始时间(用于动画的计算);
绘制元素(指向更高一级的绘制元素);
private: 绘制元素私有的指针;
编号;
矩阵(用于保存矩阵. 虽然有时 push 和 pop 更好, 但是:
	1. push 和 pop 有栈深度限制, 不同的机器不一样;
	2. push 和 pop 通常可能间隔很多绘制指令, 中间的指令可能在矩阵操作中不对称)
(但是如果有自信, 不一定保存矩阵)
立刻结束标志: 当用户按下某个键时, 需要一种机制通知这个绘制立刻到达终止状态.


这个结构, 由于有 private 指针, 因此必须用自己的方法销毁. 上面有一个销毁函数指针.

有两种 RenderCommand: 1. 内部的, 简单的显示, 移动, 绘制指令. 这些 Command 和它
们所属的 RenderElement 无关. 2. Element 特有的. 

绘制链表(RenderList):

由绘制指令构成的一个链表.

提供一个 display 函数, 供上层调用. 每调用一次绘制一遍. 参数是距初始化的时间. 这
里可能要考虑时钟回滚问题.

\subsection{配置接口}

这一层的静态配置的都是底层显示, 包括: 分辨率, 全屏, 色彩等; 动态配置应该包括
全屏/窗口切换, 分辨率变化, 鼠标, X11 窗口号(放电影用)等等.

每个特效应该有自己的静态配置和动态配置, 和本系统无关.

\subsection{初始化}

1. 初始化 OpenGL 管理器, 检查 opengl 版本是否符合最低要求;
2. 读取配置, 初始化 SDL 和 OpenGL;
3. 初始化绘制指令链表. 

\subsection{纹理管理器}

考虑到不同机器纹理的特点不一样, 在大部分机器上可以用一个纹理展示的在某些机器上只
能使用 64x64 的纹理; 有的机器不支持 NPOT 纹理. 纹理管理器提供一个抽象``纹理'', 
还提供一个抽象的``绘制''函数, 用于适应不同平台.

纹理管理器在初始化时检查平台支持的最大纹理, 是否支持 NPOT 纹理. 绘制函数可以在纹
理管理器中创建一个纹理, 并调用绘制函数绘制这个纹理.   考虑到平台可能不支持太多纹
理, 这个管理器需要对纹理进行替换. 这就产生了和 Cache 一样的问题. 纹理管理器需要
能够将纹理 pin 在显存中, 不被换出. 

\subsection{OpenGL 检查}

初始化时读取 OpenGL 串, 提供接口用于查询; 对于一些扩展函数, 用 get address 获得
函数地址.


\end{document}

